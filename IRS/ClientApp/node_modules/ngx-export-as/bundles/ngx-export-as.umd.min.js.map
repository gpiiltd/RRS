{"version":3,"sources":["ng://ngx-export-as/lib/export-as.service.ts","ng://ngx-export-as/lib/export-as.module.ts"],"names":["window","html2canvas","ExportAsService","prototype","get","config","func","type","toUpperCase","this","Observable","create","observer","error","save","fileName","download","subscribe","contentToBlob","content","arr","split","mime","match","bstr","atob","n","length","u8arr","Uint8Array","charCodeAt","next","Blob","complete","removeFileTypeFromBase64","fileContent","Symbol","replace","addFileTypeToBase64","fileMime","downloadFromDataURL","dataURL","_this","blob","downloadFromBlob","url","URL","createObjectURL","navigator","msSaveOrOpenBlob","element","document","createElement","setAttribute","style","display","body","appendChild","href","click","removeChild","getPDF","options","filename","getElementById","elementId","pdf","html2pdf","set","from","outputPdf","then","data","getPNG","canvas","imgData","toDataURL","err","getCSV","csv","rows","querySelectorAll","index","row","cols","colIndex","col","push","innerText","join","csvContent","btoa","getTXT","nameFrags","getXLS","ws3","XLSX.utils","table_to_sheet","wb","book_new","book_append_sheet","xlsContent","XLSX.write","getXLSX","getDOCX","outerHTML","converted","htmlDocx.asBlob","reader_1","FileReader","onloadend","base64data","result","readAsDataURL","getDOC","getJSON","headers","table","cells","innerHTML","toLowerCase","i","tableRow","rowData","j","jsonString","JSON","stringify","dataStr","getXML","xml","tritem","getElementsByTagName","celldata","textContent","m","base64","unescape","encodeURIComponent","Injectable","ExportAsModule","NgModule","args","providers"],"mappings":"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","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nimport { ExportAsConfig } from './export-as-config.model';\n\nimport html2canvas from 'html2canvas';\nimport * as XLSX from 'xlsx';\nimport * as htmlDocx from 'html-docx-js/dist/html-docx';\nimport html2pdf from 'html2pdf.js';\n\nwindow['html2canvas'] = html2canvas;\n\n@Injectable()\nexport class ExportAsService {\n\n  constructor() { }\n\n  /**\n   * Main base64 get method, it will return the file as base64 string\n   * @param config your config\n   */\n  get(config: ExportAsConfig): Observable<string | null> {\n    // structure method name dynamically by type\n    const func = 'get' + config.type.toUpperCase();\n    // if type supported execute and return\n    if (this[func]) {\n      return this[func](config);\n    }\n\n    // throw error for unsupported formats\n    return Observable.create((observer) => { observer.error('Export type is not supported.'); });\n  }\n\n  /**\n   * Save exported file in old javascript way\n   * @param config your custom config\n   * @param fileName Name of the file to be saved as\n   */\n  save(config: ExportAsConfig, fileName: string): void {\n    // set download\n    config.download = true;\n    // get file name with type\n    config.fileName = fileName + '.' + config.type;\n    this.get(config).subscribe();\n  }\n\n  /**\n   * Converts content string to blob object\n   * @param content string to be converted\n   */\n  contentToBlob(content: string): Observable<Blob> {\n    return Observable.create((observer) => {\n      // get content string and extract mime type\n      const arr = content.split(','), mime = arr[0].match(/:(.*?);/)[1],\n        bstr = atob(arr[1]);\n      let n = bstr.length;\n      const u8arr = new Uint8Array(n);\n      while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n      }\n      observer.next(new Blob([u8arr], { type: mime }));\n      observer.complete();\n    });\n  }\n\n  /**\n   * Removes base64 file type from a string like \"data:text/csv;base64,\"\n   * @param fileContent the base64 string to remove the type from\n   */\n  removeFileTypeFromBase64(fileContent: string): string {\n    const re = /^data:[^]*;base64,/g;\n    const newContent: string = re[Symbol.replace](fileContent, '');\n    return newContent;\n  }\n\n  /**\n   * Structure the base64 file content with the file type string\n   * @param fileContent file content\n   * @param fileMime file mime type \"text/csv\"\n   */\n  addFileTypeToBase64(fileContent: string, fileMime: string): string {\n    return `data:${fileMime};base64,${fileContent}`;\n  }\n\n  /**\n   * create downloadable file from dataURL\n   * @param fileName downloadable file name\n   * @param dataURL file content as dataURL\n   */\n  downloadFromDataURL(fileName: string, dataURL: string): void {\n    // create blob\n    this.contentToBlob(dataURL).subscribe(blob => {\n      // download the blob\n      this.downloadFromBlob(blob, fileName);\n    });\n  }\n\n  /**\n   * Downloads the blob object as a file\n   * @param blob file object as blob\n   * @param fileName downloadable file name\n   */\n  downloadFromBlob(blob: Blob, fileName: string) {\n    // get object url\n    const url = window.URL.createObjectURL(blob);\n    // check for microsoft internet explorer\n    if (window.navigator && window.navigator.msSaveOrOpenBlob) {\n      // use IE download or open if the user using IE\n      window.navigator.msSaveOrOpenBlob(blob, fileName);\n    } else {\n      // if not using IE then create link element\n      const element = document.createElement('a');\n      // set download attr with file name\n      element.setAttribute('download', fileName);\n      // set the element as hidden\n      element.style.display = 'none';\n      // append the body\n      document.body.appendChild(element);\n      // set href attr\n      element.href = url;\n      // click on it to start downloading\n      element.click();\n      // remove the link from the dom\n      document.body.removeChild(element);\n    }\n  }\n\n  private getPDF(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      if (!config.options) {\n        config.options = {};\n      }\n      config.options.filename = config.fileName;\n      const element: HTMLElement = document.getElementById(config.elementId);\n      const pdf = html2pdf().set(config.options).from(element, 'element');\n      if (config.download) {\n        pdf.save();\n        observer.next();\n        observer.complete();\n      } else {\n        pdf.outputPdf('datauristring').then(data => {\n          observer.next(data);\n          observer.complete();\n        });\n      }\n    });\n  }\n\n  private getPNG(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const element: HTMLElement = document.getElementById(config.elementId);\n      html2canvas(element, config.options).then((canvas) => {\n        const imgData = canvas.toDataURL('image/PNG');\n        if (config.type === 'png' && config.download) {\n          this.downloadFromDataURL(config.fileName, imgData);\n          observer.next();\n        } else {\n          observer.next(imgData);\n        }\n        observer.complete();\n      }, err => {\n        observer.error(err);\n      });\n    });\n  }\n\n  private getCSV(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const element: HTMLElement = document.getElementById(config.elementId);\n      const csv = [];\n      const rows: any = element.querySelectorAll('table tr');\n      for (let index = 0; index < rows.length; index++) {\n        const rowElement = rows[index];\n        const row = [];\n        const cols = rowElement.querySelectorAll('td, th');\n        for (let colIndex = 0; colIndex < cols.length; colIndex++) {\n          const col = cols[colIndex];\n          row.push(col.innerText);\n        }\n        csv.push(row.join(','));\n      }\n      const csvContent = 'data:text/csv;base64,' + this.btoa(csv.join('\\n'));\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, csvContent);\n        observer.next();\n      } else {\n        observer.next(csvContent);\n      }\n      observer.complete();\n    });\n  }\n\n  private getTXT(config: ExportAsConfig): Observable<string | null> {\n    const nameFrags = config.fileName.split('.');\n    config.fileName = `${nameFrags[0]}.txt`;\n    return this.getCSV(config);\n  }\n\n  private getXLS(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n\n      const element: HTMLElement = document.getElementById(config.elementId);\n      const ws3 = XLSX.utils.table_to_sheet(element, config.options);\n      const wb = XLSX.utils.book_new();\n      XLSX.utils.book_append_sheet(wb, ws3, config.fileName);\n      const out = XLSX.write(wb, { type: 'base64' });\n      const xlsContent = 'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + out;\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, xlsContent);\n        observer.next();\n      } else {\n        observer.next(xlsContent);\n      }\n      observer.complete();\n    });\n  }\n\n  private getXLSX(config: ExportAsConfig): Observable<string | null> {\n    return this.getXLS(config);\n  }\n\n  private getDOCX(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      const contentDocument: string = document.getElementById(config.elementId).outerHTML;\n      const content = '<!DOCTYPE html>' + contentDocument;\n      const converted = htmlDocx.asBlob(content, config.options);\n      if (config.download) {\n        this.downloadFromBlob(converted, config.fileName);\n        observer.next();\n        observer.complete();\n      } else {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          const base64data = reader.result;\n          observer.next(base64data);\n          observer.complete();\n        };\n        reader.readAsDataURL(converted);\n      }\n    });\n  }\n\n  private getDOC(config: ExportAsConfig): Observable<string | null> {\n    return this.getDOCX(config);\n  }\n\n  private getJSON(config: ExportAsConfig): Observable<any[] | null> {\n    return Observable.create((observer) => {\n      const data = []; // first row needs to be headers\n      const headers = [];\n      const table = <HTMLTableElement>document.getElementById(config.elementId);\n      for (let index = 0; index < table.rows[0].cells.length; index++) {\n        headers[index] = table.rows[0].cells[index].innerHTML.toLowerCase().replace(/ /gi, '');\n      }\n      // go through cells\n      for (let i = 1; i < table.rows.length; i++) {\n        const tableRow = table.rows[i]; const rowData = {};\n        for (let j = 0; j < tableRow.cells.length; j++) {\n          rowData[headers[j]] = tableRow.cells[j].innerHTML;\n        }\n        data.push(rowData);\n      }\n      const jsonString = JSON.stringify(data);\n      const jsonBase64 = this.btoa(jsonString);\n      const dataStr = 'data:text/json;base64,' + jsonBase64;\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, dataStr);\n        observer.next();\n      } else {\n        observer.next(data);\n      }\n      observer.complete();\n    });\n  }\n\n  private getXML(config: ExportAsConfig): Observable<string | null> {\n    return Observable.create((observer) => {\n      let xml = '<?xml version=\"1.0\" encoding=\"UTF-8\"?><Root><Classes>';\n      const tritem = document.getElementById(config.elementId).getElementsByTagName('tr');\n      for (let i = 0; i < tritem.length; i++) {\n        const celldata = tritem[i];\n        if (celldata.cells.length > 0) {\n          xml += '<Class name=\"' + celldata.cells[0].textContent + '\">\\n';\n          for (let m = 1; m < celldata.cells.length; ++m) {\n            xml += '\\t<data>' + celldata.cells[m].textContent + '</data>\\n';\n          }\n          xml += '</Class>\\n';\n        }\n      }\n      xml += '</Classes></Root>';\n      const base64 = 'data:text/xml;base64,' + this.btoa(xml);\n      if (config.download) {\n        this.downloadFromDataURL(config.fileName, base64);\n        observer.next();\n      } else {\n        observer.next(base64);\n      }\n      observer.complete();\n    });\n  }\n\n  private btoa(content: string) {\n    return btoa(unescape(encodeURIComponent(content)));\n  }\n\n}\n","/**\n * angular imports\n */\nimport { NgModule } from '@angular/core';\n\n/**\n * my imports\n */\nimport { ExportAsService } from './export-as.service';\n\n@NgModule({\n  providers: [ExportAsService],\n})\nexport class ExportAsModule { }\n\n\n"]}